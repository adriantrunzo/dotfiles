" Manually set terminal features in Kitty until vim terminal feature detection
" is improved.
" https://sw.kovidgoyal.net/kitty/faq/#using-a-color-theme-with-a-background-color-does-not-work-well-in-vim
if &term == 'xterm-kitty'
  " Mouse support
  set mouse=a
  set ttymouse=sgr
  set balloonevalterm

  " Styled and colored underline support
  let &t_AU = "\e[58:5:%dm"
  let &t_8u = "\e[58:2:%lu:%lu:%lum"
  let &t_Us = "\e[4:2m"
  let &t_Cs = "\e[4:3m"
  let &t_ds = "\e[4:4m"
  let &t_Ds = "\e[4:5m"
  let &t_Ce = "\e[4:0m"

  " Strikethrough
  let &t_Ts = "\e[9m"
  let &t_Te = "\e[29m"

  " Truecolor support
  let &t_8f = "\e[38:2:%lu:%lu:%lum"
  let &t_8b = "\e[48:2:%lu:%lu:%lum"
  let &t_RF = "\e]10;?\e\\"
  let &t_RB = "\e]11;?\e\\"

  " Bracketed paste
  let &t_BE = "\e[?2004h"
  let &t_BD = "\e[?2004l"
  let &t_PS = "\e[200~"
  let &t_PE = "\e[201~"

  " Cursor control
  let &t_RC = "\e[?12$p"
  let &t_SH = "\e[%d q"
  let &t_RS = "\eP$q q\e\\"
  let &t_SI = "\e[5 q"
  let &t_SR = "\e[3 q"
  let &t_EI = "\e[1 q"
  let &t_VS = "\e[?12l"

  " Focus tracking
  let &t_fe = "\e[?1004h"
  let &t_fd = "\e[?1004l"
  execute "set <FocusGained>=\<Esc>[I"
  execute "set <FocusLost>=\<Esc>[O"

  " Window title
  let &t_ST = "\e[22;2t"
  let &t_RT = "\e[23;2t"

  " vim hardcodes background color erase even if the terminfo file does
  " not contain bce. This causes incorrect background rendering when
  " using a color theme with a background color in terminals such as
  " kitty that do not support background color erase.
  let &t_ut=''
endif

" Enable filetype and indent detection.
filetype plugin indent on

" Enable syntax highlighting.
syntax enable

" Use the Dracula color scheme.
colorscheme dracula

" Create new lines at the same indentation level.
set autoindent

" Detect file changes outside of vim and reload those files if not changed.
set autoread

" Use colors suitable for a dark background. The colorscheme should also set
" this value.
set background=dark

" Allow backspacing over everything in insert mode.
set backspace=indent,eol,start

" Don't put backup files in the current directory.
set backupdir^=$HOME/.vim/backup//

" Don't ring the bell.
set belloff=all

" Highlight the column after textwidth.
set colorcolumn=+1

" Don't put swap files in the current directory.
set directory^=$HOME/.vim/swap//

" Use utf-8 by default.
set encoding=utf-8

" Expand tabs to spaces in insert mode.
set expandtab

" Remove comment leader when joining lines.
set formatoptions+=j

" Allow for hidden buffers. Necessary for some plugins.
set hidden

" Highlight search results.
set hlsearch

" Ignore case when searching.
set ignorecase

" Show matches as search proceeds.
set incsearch

" Always show the status line.
set laststatus=2

" Show line numbers.
set number

" Make the line numbers relative.
set relativenumber

" Always show lines above and below cursor when scrolling.
set scrolloff=8

" Always show the signcolumn, otherwise it would shift the text each time
" diagnostics appear/become resolved.
set signcolumn=yes

" Use two spaces when indenting.
set shiftwidth=2

" Don't pass messages to |ins-completion-menu|.
set shortmess+=c

" Show a symbol for wrapped lines.
set showbreak=â†ª

" Show partial commands in the last line.
set showcmd

" Make search case-sensitive if capital letters are used.
set smartcase

" Use two spaces for the tab key.
set softtabstop=2

" Open horizontal splits below.
set splitbelow

" Open vertical splits to the right.
set splitright

" Statusline with useful information.
set statusline=
set statusline+=%{GetGitBranch()}
set statusline+=\ %f%m%r%q
set statusline+=%=
set statusline+=%{GetDiagnosticStatus()}
set statusline+=\ %y
set statusline+=\ %{&fileencoding?&fileencoding:&encoding}
set statusline+=\[%{&fileformat}\]
set statusline+=\ %l:%L
set statusline+=\ %c

" Enable true color.
set termguicolors

" Break text after 80 characters.
set textwidth=80

" Time out for key codes.
set ttimeout

" Wait up to 100ms after Esc for special key.
set ttimeoutlen=100

" Set the title of the terminal window appropriately.
set title

" Don't put undo files in the current directory.
set undodir^=$HOME/.vim/undo//

" Persistent undo.
set undofile

" coc.nvim recommends a lower updatetime, which is used by the highlight on
" CursorHold feature.
set updatetime=500

" Enable wildmenu (command-line completion).
set wildmenu

" Use fuzzy matching and the pum for the wildmenu.
set wildoptions=fuzzy,pum

" Wrap long lines.
set wrap

" Disable default mappings in the following plugins.
let g:FerretMap = 0
let g:gitgutter_map_keys = 0
let g:move_map_keys = 0
let g:nnn#set_default_mappings = 0
let g:sandwich_no_default_key_mappings = 1
let g:swap_no_default_key_mappings = 1

" Use bars for git signs as they are easier to read at a glance.
let g:gitgutter_sign_added = '|'
let g:gitgutter_sign_modified = '|'
let g:gitgutter_sign_removed = '|'
let g:gitgutter_sign_removed_first_line = '|'
let g:gitgutter_sign_removed_above_and_below = '|'
let g:gitgutter_sign_modified_removed = '|'

" Text objects to select the nearest surrounded text automatically.
xmap im <Plug>(textobj-sandwich-auto-i)
omap im <Plug>(textobj-sandwich-auto-i)
xmap am <Plug>(textobj-sandwich-auto-a)
omap am <Plug>(textobj-sandwich-auto-a)

" Swappable (eg arguments) text objects.
xmap i, <Plug>(swap-textobject-i)
omap i, <Plug>(swap-textobject-i)
xmap a, <Plug>(swap-textobject-a)
omap a, <Plug>(swap-textobject-a)

" Use tab for switching windows. Using a count goes to that window.
nnoremap <Tab> <C-W>w
nnoremap <S-Tab> <C-W>W

" Just type enter to insert below. Shift enter above.
nnoremap <CR> o
nnoremap <S-CR> O
xnoremap <CR> o
xnoremap <S-CR> O

" Alt-enter to insert blank lines above and below.
nnoremap <A-CR> <Cmd>put=repeat([''],v:count)<Bar>'[-1<CR>
nnoremap <A-S-CR> <Cmd>put!=repeat([''],v:count)<Bar>']+1<CR>

" Reselect visual selection after indenting.
vnoremap < <gv
vnoremap > >gv

" Quick change the word under the cursor.
nmap cn *``cgn
nmap cN *``cgN

" Move vertically by visual line with wrapping enabled.
nnoremap j gj
nnoremap k gk

" Maintain the cursor position when joining lines.
nnoremap J mzJ`z

" Integrate LSP into keyword lookup.
nnoremap K <Cmd>call ShowDocumentation()<CR>

" Unmap default m behavior.
map m <Nop>

" Use m for "match" mappings.
nmap ma <Plug>(sandwich-add)
xmap ma <Plug>(sandwich-add)
omap ma <Plug>(sandwich-add)
nmap md <Plug>(sandwich-delete)
xmap md <Plug>(sandwich-delete)
nmap mdd <Plug>(sandwich-delete-auto)
nmap mr <Plug>(sandwich-replace)
xmap mr <Plug>(sandwich-replace)
nmap mrr <Plug>(sandwich-replace-auto)

" Keep the cursor centered when going through search results.
nnoremap n nzzzv
nnoremap N Nzzzv

" Use o for controlling comments.
xmap o <Plug>Commentary
nmap o <Plug>Commentary
omap o <Plug>Commentary
nmap oo <Plug>CommentaryLine
" Ideally this mapping could comment from cursor to line end.
map O <Nop>

" Ex mode is rarely useful.
nnoremap q @
nnoremap Q q

" Use s/S for sneak everywhere since it won't confict with surround mappings.
omap s <Plug>Sneak_s
omap S <Plug>Sneak_S
xmap S <Plug>Sneak_S

" Better redo.
nnoremap U <C-r>

" Make Y behave as expected, though don't yank the trailing whitespace.
nnoremap Y yg_

" Maintain the cursor position when yanking a visual selection.
" http://ddrscott.github.io/blog/2016/yank-without-jank/
vnoremap y myy`y
vnoremap Y myY`y

" Autocompletion: Use enter to trigger completions and tab to cycle options.
inoremap <expr> <cr> coc#pum#visible() ? coc#_select_confirm() : "\<C-g>u\<cr>"
inoremap <expr> <tab> coc#pum#visible() ? coc#pum#next(1) : "\<tab>"
inoremap <expr> <s-tab> coc#pum#visible() ? coc#pum#prev(1) : "\<s-tab>"

" Remap <C-f> and <C-b> for scroll float windows/popups.
nnoremap <silent><nowait><expr> <C-f> coc#float#has_scroll() ? coc#float#scroll(1) : "\<C-f>"
nnoremap <silent><nowait><expr> <C-b> coc#float#has_scroll() ? coc#float#scroll(0) : "\<C-b>"
inoremap <silent><nowait><expr> <C-f> coc#float#has_scroll() ? "\<C-r>=coc#float#scroll(1)\<cr>" : "\<Right>"
inoremap <silent><nowait><expr> <C-b> coc#float#has_scroll() ? "\<C-r>=coc#float#scroll(0)\<cr>" : "\<Left>"
vnoremap <silent><nowait><expr> <C-f> coc#float#has_scroll() ? coc#float#scroll(1) : "\<C-f>"
vnoremap <silent><nowait><expr> <C-b> coc#float#has_scroll() ? coc#float#scroll(0) : "\<C-b>"

nnoremap <A-B> <Cmd>bprevious<CR>
nnoremap <A-b> <Cmd>bnext<CR>
nmap <A-D> <plug>(coc-diagnostic-prev)
nmap <A-d> <plug>(coc-diagnostic-next)
nmap <A-E> <plug>(coc-diagnostic-prev-error)
nmap <A-e> <plug>(coc-diagnostic-next-error)
nmap <A-H> <Plug>(GitGutterPrevHunk)
nmap <A-h> <Plug>(GitGutterNextHunk)
nnoremap <A-T> gT
nnoremap <A-t> gt
nnoremap <A-Q> <cmd>cprevious<cr>
nnoremap <A-q> <cmd>cnext<cr>

" Move text in all directions.
nmap <A-Down> <Plug>MoveLineDown
nmap <A-Up> <Plug>MoveLineUp
nmap <A-Left> <Plug>MoveCharLeft
nmap <A-Right> <Plug>MoveCharRight
vmap <A-Down> <Plug>MoveBlockDown
vmap <A-Up> <Plug>MoveBlockUp
vmap <A-Left> <Plug>MoveBlockLeft
vmap <A-Right> <Plug>MoveBlockRight

" Use space for leader. 
let mapleader = ' '

nmap <silent> <Leader><Space> <Plug>(CommandT)
nnoremap <leader>d <cmd>bdelete<cr>
nmap <leader>ca <plug>(coc-codeaction)
nmap <leader>cc <plug>(coc-fix-current)
nmap <leader>cd <plug>(coc-definition)
nmap <leader>cf <plug>(coc-refactor)
nmap <leader>ci <plug>(coc-implementation)
nmap <leader>cl <cmd>CocList diagnostics<cr>
nmap <leader>cn <plug>(coc-rename)
nmap <leader>cr <plug>(coc-references)
nmap <leader>cs <plug>(coc-codeaction-selected)
xmap <leader>cs <plug>(coc-codeaction-selected)
nmap <leader>ct <plug>(coc-type-definition)
nnoremap <leader>e <cmd>NnnPicker %:p:h<CR>
nmap <leader>fa <Plug>(FerretAck)
nmap <leader>ff <Plug>(FerretAckWord)
nmap <leader>fl <Plug>(FerretLack)
nmap <leader>fq <Plug>(FerretQuack)
nmap <leader>fr <Plug>(FerretAcks)
nnoremap <leader>g <cmd>Git<cr>
nmap <Leader>hp <Plug>(GitGutterPreviewHunk)
nmap <Leader>hs <Plug>(GitGutterStageHunk)
nmap <Leader>hu <Plug>(GitGutterUndoHunk)
nnoremap <Leader>m <Cmd>make<CR>
nnoremap <leader>p "*p
nnoremap <leader>P "*P
xnoremap <leader>p "*p
nnoremap <leader>q <cmd>quit<cr>
nnoremap <leader>s <cmd>update<cr>
nnoremap <leader>vc <cmd>edit $MYVIMRC<cr>
nnoremap <leader>vr <cmd>source $MYVIMRC<cr>
nnoremap <leader>wc <c-w>c
nnoremap <leader>wh <c-w>s
nnoremap <leader>wn <c-w>n
nnoremap <leader>wv <c-w>v
nnoremap <leader>x <cmd>exit<cr>
nnoremap <leader>y "*y
nnoremap <leader>Y "*Y
xnoremap <leader>y "*y

" Opens the nÂ³ window in the same window like netrw.
let g:nnn#layout = 'enew'

" Use nÂ³ when opening directories instead of netrw.
let g:nnn#replace_netrw = 1

" Use the git file scanner, which falls back to find when not in a repository.
" Please show untracked files, though. The debounce is nice in larger
" repositories and otherwise not noticeable.
let g:CommandTFileScanner = 'git'
let g:CommandTInputDebounce = 100
let g:CommandTGitIncludeUntracked = 1

" Don't show offscreen matches as they cause odd statusline issues.
let g:matchup_matchparen_offscreen = {}

" Use the sneak label mode for faster jumping.
let g:sneak#label = 1

" Coc Extensions. These should be automatically installed by coc.nvim.
let g:coc_global_extensions = [
      \ 'coc-css',
      \ 'coc-cssmodules',
      \ 'coc-docker',
      \ 'coc-eslint',
      \ 'coc-go',
      \ 'coc-html',
      \ 'coc-json',
      \ 'coc-lists',
      \ 'coc-prettier',
      \ 'coc-solargraph',
      \ 'coc-tsserver',
      \ 'coc-vimlsp'
      \ ]

" More colorful JSX.
let g:vim_jsx_pretty_colorful_config = 1

augroup Config
  autocmd!
  " TODO: Comment here.
  " autocmd VimEnter * runtime $VIMRUNTIME/compiler/eslint.vim

  " In certain buffers, mapping <CR> can be problematic.
  autocmd BufReadPost * if !empty(&bt) | call DisableEnderMapping() | endif
  autocmd CmdWinEnter * call DisableEnderMapping()
  autocmd FileType qf call DisableEnderMapping()

  " These files should be treated as JSONC.
  autocmd BufNewFile,BufRead .eslintrc.json setlocal filetype=jsonc
  autocmd BufNewFile,BufRead tsconfig.json setlocal filetype=jsonc

  autocmd FileType javascript,javascriptreact call ConfigureJavaScript()
  autocmd FileType typescript,typescriptreact call ConfigureTypeScript()

  " Update signature help on jump placeholder.
  autocmd User CocJumpPlaceholder call CocActionAsync('showSignatureHelp')

  " Highlight the symbol and its references when holding the cursor.
  autocmd CursorHold * silent call CocActionAsync('highlight')
augroup end

function! ConfigureJavaScript() abort
  setlocal makeprg=npx\ eslint\ --fix\ --format\ compact\ %
  setlocal errorformat=%f:\ line\ %l\\,\ col\ %c\\,\ %m,%-G%.%#
  setlocal formatprg=npx\ prettier\ --loglevel\ silent\ --stdin-filepath\ %
endfunction

function! ConfigureTypeScript() abort
  setlocal formatexpr&
  call ConfigureJavaScript()
endfunction

function! GetDiagnosticStatus() abort
  let diagnostics = get(b:, 'coc_diagnostic_info', {})

  if (empty(diagnostics))
    return ''
  endif

  let errorCount = get(diagnostics, 'error', 0)
  let warnCount = get(diagnostics, 'warning', 0)

  let statuses = []

  if (!empty(warnCount))
    call add(statuses, 'W:' . warnCount)
  endif

  if (!empty(errorCount))
    call add(statuses, 'E:' . errorCount)
  endif

  return join(statuses, ',')
endfunction

function! GetGitBranch() abort
  let fugitive = FugitiveStatusline()

  " This file is not in a git directory.
  if (strlen(fugitive) == 0)
    return ''
  endif

  let matches = matchlist(fugitive, '^\[Git(\(.\+\))\]$')

  " Could not parse the fugitive output for some reason.
  if (len(matches) == 0)
    return ''
  endif

  let branch = matches[1]

  " Shortcut git branches contain the ticket identifier preceeded by "sc-".
  let story = matchstr(branch, 'sc-\d\+')

  " Use the identifier segment if we found one.
  if (strlen(story) > 0)
    return '[' . story[:strlen(story) - 1] . ']'
  endif

  " Otherwise the first ten characters.
  return '[' . branch[:9] . ']'
endfunction

" Show documentation in preview window.
function! ShowDocumentation() abort
  if CocAction('hasProvider', 'hover')
    call CocActionAsync('doHover')
  else
    call feedkeys('K', 'in')
  endif
endfunction

function! DisableEnderMapping() abort
  noremap <buffer> <CR> <CR>
endfunction

let s:RE_WORD = '\%(\w\+\)'
let s:RE_ATTR_NAME = '\%([a-zA-Z0-9\-_:@.]\+\)'
let s:RE_QUOTED_STR = '\%(".\{-}"\|''.\{-}''\)'
let s:RE_JSX_BLOCK = '\%({\_.\{-}\%(}}\|}\)\%(\/>\|[ \n>]\)\@=\)'
let s:RE_ATTR_VALUE = '\%(' . s:RE_QUOTED_STR . '\|' . s:RE_WORD . '\|' . s:RE_JSX_BLOCK . '\)'
let s:RE_ATTR_RHS = '\%(=' . s:RE_ATTR_VALUE . '\)\='
let s:RE_ATTR = '\%(' . s:RE_ATTR_NAME . s:RE_ATTR_RHS . '\)'
let s:RE_ATTR_WITH_SPACE = '\%(\_s*' . s:RE_ATTR . '\)'
" let s:RE_ATTR_A = '\(' . s:RE_ATTR_WITH_SPACE . '\)'
" let s:RE_JSX_TAG = '<?\?\h\w*\_s*\zs\%(' . s:RE_ATTR_WITH_SPACE . '\)*\ze\_s*/\?>'

call textobj#user#plugin('tagattr', {
\   'attr-i': {
\     'pattern': s:RE_ATTR,
\     'select': 'ix',
\   },
\   'attr-a': {
\     'pattern': s:RE_ATTR_WITH_SPACE,
\     'select': 'ax',
\   },
\ })
