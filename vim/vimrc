" Manually set terminal features in Kitty until vim terminal feature detection
" is improved.
" https://sw.kovidgoyal.net/kitty/faq/#using-a-color-theme-with-a-background-color-does-not-work-well-in-vim
if &term == 'xterm-kitty'
    " Styled and colored underline support
    let &t_AU = "\e[58:5:%dm"
    let &t_8u = "\e[58:2:%lu:%lu:%lum"
    let &t_Us = "\e[4:2m"
    let &t_Cs = "\e[4:3m"
    let &t_ds = "\e[4:4m"
    let &t_Ds = "\e[4:5m"
    let &t_Ce = "\e[4:0m"

    " Strikethrough
    let &t_Ts = "\e[9m"
    let &t_Te = "\e[29m"

    " Truecolor support
    let &t_8f = "\e[38:2:%lu:%lu:%lum"
    let &t_8b = "\e[48:2:%lu:%lu:%lum"
    let &t_RF = "\e]10;?\e\\"
    let &t_RB = "\e]11;?\e\\"

    " Bracketed paste
    let &t_BE = "\e[?2004h"
    let &t_BD = "\e[?2004l"
    let &t_PS = "\e[200~"
    let &t_PE = "\e[201~"

    " Cursor control
    let &t_RC = "\e[?12$p"
    let &t_SH = "\e[%d q"
    let &t_RS = "\eP$q q\e\\"
    let &t_SI = "\e[5 q"
    let &t_SR = "\e[3 q"
    let &t_EI = "\e[1 q"
    let &t_VS = "\e[?12l"

    " Focus tracking
    let &t_fe = "\e[?1004h"
    let &t_fd = "\e[?1004l"
    execute "set <FocusGained>=\<Esc>[I"
    execute "set <FocusLost>=\<Esc>[O"

    " Window title
    let &t_ST = "\e[22;2t"
    let &t_RT = "\e[23;2t"
endif

" Autocommand group to use throughout this configuration file.
augroup Config
    autocmd!
augroup end

" Customize the dracula theme. Must be called before colorscheme.
autocmd Config ColorScheme dracula call s:handle_colorscheme_dracula()

function! s:handle_colorscheme_dracula() abort
    highlight link CurSearch IncSearch
    highlight link CocErrorSign DraculaWarning
endfunction

" Enable filetype and indent detection.
filetype plugin indent on

" Enable syntax highlighting.
syntax enable

" Use the Dracula color scheme.
colorscheme dracula

" Create new lines at the same indentation level.
set autoindent

" Detect file changes outside of vim and reload those files if not changed.
set autoread

" Use colors suitable for a dark background. The colorscheme should also set
" this value.
set background=dark

" Allow backspacing over everything in insert mode.
set backspace=indent,eol,start

" Don't put backup files in the current directory.
set backupdir^=$HOME/.vim/backup//

" Don't ring the bell.
set belloff=all

" Highlight the column after textwidth.
set colorcolumn=+1

" Don't put swap files in the current directory.
set directory^=$HOME/.vim/swap//

" Use utf-8 by default.
set encoding=utf-8

" Expand tabs to spaces in insert mode.
set expandtab

" Remove comment leader when joining lines.
set formatoptions+=j

" Allow for hidden buffers. Necessary for some plugins.
set hidden

" Highlight search results.
set hlsearch

" Ignore case when searching.
set ignorecase

" Show matches as search proceeds.
set incsearch

" Always show the status line.
set laststatus=2

" Show line numbers.
set number

" Make the line numbers relative.
set relativenumber

" Always show lines above and below cursor when scrolling.
set scrolloff=8

" Always show the signcolumn, otherwise it would shift the text each time
" diagnostics appear/become resolved.
set signcolumn=yes

" Use two spaces when indenting.
set shiftwidth=2

" Display the number of search results.
set shortmess-=S

" Don't pass messages to |ins-completion-menu|.
set shortmess+=c

" Show a symbol for wrapped lines.
set showbreak=↪

" Show partial commands in the last line.
set showcmd

" Don't show the mode as vim-airline will already display it for us.
set noshowmode

" Make search case-sensitive if capital letters are used.
set smartcase

" Use two spaces for the tab key.
set softtabstop=2

" Open horizontal splits below.
set splitbelow

" Don't shift the buffer when splitting below.
set splitkeep=topline

" Open vertical splits to the right.
set splitright

" Enable true color.
set termguicolors

" Break text after 80 characters.
set textwidth=80

" Time out for key codes.
set ttimeout

" Wait up to 100ms after Esc for special key.
set ttimeoutlen=100

" Set the title of the terminal window appropriately.
set title

" Don't put undo files in the current directory.
set undodir^=$HOME/.vim/undo//

" Persistent undo.
set undofile

" Faster update time for git signs, etc. 
set updatetime=500

" Enable wildmenu (command-line completion).
set wildmenu

" Use fuzzy matching and the pum for the wildmenu.
set wildoptions=fuzzy,pum

" Wrap long lines.
set wrap

if has('osx')
    " Load the fzf plugin included with the homebrew install.
    set rtp+=/opt/homebrew/opt/fzf
endif

" Ripgrep is much faster.
if executable("rg")
    set grepprg=rg\ --vimgrep\ --smart-case\ --hidden
    set grepformat+=%f:%l:%c:%m
endif

" Use space for leader. 
let mapleader = '?'

" Use dracula in airline and remove all of the symbols.
let g:airline_theme='dracula'
let g:airline_symbols_ascii = 1

if !exists('g:airline_symbols')
    let g:airline_symbols = {}
endif

" Remove the space before the line number prefix since we are removing the
" percentage indicator (see below).
let g:airline_symbols.linenr = 'ln:'

" Disable most extensions by default.
let g:airline_extensions = ['branch', 'coc', 'quickfix']

" Use a custom function to get the git branch text.
let g:airline#extensions#branch#format = 'GetGitBranch'

" A map of buffer numbers to the timestamp each buffer is opened. We manage this
" map using autocommands and use the map to sort the FZF buffer picker.
if !exists('g:buffer_timestamps')
  let g:buffer_timestamps = {}
endif

" Update the vim indent options to use less space for line continuation.
let g:vim_indent = #{
  \ line_continuation: shiftwidth(),
  \ more_in_bracket_block: v:false,
  \ searchpair_timeout: 100,
  \ }

" Disable default mappings in the following plugins.
let g:nnn#set_default_mappings = 0
let g:sandwich_no_default_key_mappings = 1
let g:swap_no_default_key_mappings = 1

" More colorful JSX.
let g:vim_jsx_pretty_colorful_config = 1

" Don't show offscreen matches as they cause odd statusline issues.
let g:matchup_matchparen_offscreen = {}

" Opens the n³ window in the same window like netrw.
let g:nnn#layout = 'enew'

" Use n³ when opening directories instead of netrw.
let g:nnn#replace_netrw = 1

" n³ split actions.
let g:nnn#action = {
  \ '<c-h>': 'split',
  \ '<c-t>': 'tab split',
  \ '<c-v>': 'vsplit'
  \ }

" Use the sneak label mode for faster jumping.
let g:sneak#label = 1

" Coc Extensions. These should be automatically installed by coc.nvim.
let g:coc_global_extensions = [
  \ 'coc-clangd',
  \ 'coc-css',
  \ 'coc-cssmodules',
  \ 'coc-eslint',
  \ 'coc-git',
  \ 'coc-html',
  \ 'coc-json',
  \ 'coc-lists',
  \ 'coc-prettier',
  \ 'coc-tsserver',
  \ 'coc-vimlsp'
  \ ]

" Swappable (eg arguments) text objects.
xmap i, <Plug>(swap-textobject-i)
omap i, <Plug>(swap-textobject-i)
xmap a, <Plug>(swap-textobject-a)
omap a, <Plug>(swap-textobject-a)

" Sandwich text-objects for surrounding characters.
xmap im <Plug>(textobj-sandwich-auto-i)
omap im <Plug>(textobj-sandwich-auto-i)
xmap am <Plug>(textobj-sandwich-auto-a)
omap am <Plug>(textobj-sandwich-auto-a)
xmap iq <Plug>(textobj-sandwich-query-i)
omap iq <Plug>(textobj-sandwich-query-i)
xmap aq <Plug>(textobj-sandwich-query-a)
omap aq <Plug>(textobj-sandwich-query-a)

" Convenient saving.
nnoremap <CR> <Cmd>update<CR>
nnoremap <S-CR> <Cmd>exit<CR>

" On the Kinesis Advantage, Space and Backspace are just under the thumbs.
nnoremap <Space> <C-d>
nnoremap <Backspace> <C-u>

" Quickly close a buffer.
nnoremap <S-Backspace> <Cmd>bdelete<CR>

" Alias for quickly scrolling through open buffers.
nnoremap <Tab> <Cmd>bnext<CR>
nnoremap <S-Tab> <Cmd>bprevious<CR>

" Use tab for cycling through completion entries in insert mode.
inoremap <expr> <CR> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"
inoremap <expr> <Tab> pumvisible() ? "\<C-n>" : "\<Tab>"
inoremap <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"

" Backslash is the same key as forward slash in the Engram layout.
noremap \ ?

" ? is the leader key.
noremap ? <Nop>

" Add LSP to K.
nnoremap K <Cmd>call <SID>show_documentation()<CR>

" Reselect visual selection after indenting.
vnoremap < <gv
vnoremap > >gv

" Unused c-mappings: cd cm co cp cq cr cs cu cx cy cz
" cs is used for sneak.
nmap <silent> cd <Plug>(coc-definition)
nmap <silent> cm <Plug>(coc-implementation)
nmap <silent> cp <Plug>(coc-type-definition)
nmap <silent> cq <Plug>(coc-format)
nmap <silent> cn <Plug>(coc-rename)
nmap <silent> cr <Plug>(coc-references)
nmap <silent> cx <Plug>(coc-declaration)
nmap <silent> cz <Plug>(coc-codeaction-selected)

" Move vertically by visual line with wrapping enabled.
nnoremap j gj
nnoremap k gk

" Use vim-sandwich for matching operations.
nmap m <Nop>
xmap m <Nop>
nmap ma <Plug>(sandwich-add)
xmap ma <Plug>(sandwich-add)
omap ma <Plug>(sandwich-add)
nmap md <Plug>(sandwich-delete)
xmap md <Plug>(sandwich-delete)
nmap mdd <Plug>(sandwich-delete-auto)
nmap mr <Plug>(sandwich-replace)
xmap mr <Plug>(sandwich-replace)
nmap mrr <Plug>(sandwich-replace-auto)

" Moving text.
nnoremap mk :m .-2<cr>==
vnoremap mk :m '<-2<cr>gv=gv
nnoremap mj :m .+1<cr>==
vnoremap mj :m '>+1<cr>gv=gv
nmap mh <Plug>(swap-prev)
nmap ml <Plug>(swap-next)
nmap gs <Plug>(swap-interactive)
xmap gs <Plug>(swap-interactive)

" Keep the cursor centered when going through search results.
nnoremap n nzzzv
nnoremap N Nzzzv

" Ex mode is rarely useful.
nnoremap q @
nnoremap Q q

" Use s for sneak in all modes.
omap s <Plug>Sneak_s
omap S <Plug>Sneak_S
xmap S <Plug>Sneak_S

" Better redo.
nnoremap U <C-r>

" Substitute over a range. x is mostly redundant with d.
nmap x <Plug>(SubversiveSubstituteRange)
xmap x <Plug>(SubversiveSubstituteRange)
nmap xx <Plug>(SubversiveSubstituteWordRange)
nmap X <Plug>(SubversiveSubstituteRangeConfirm)
xmap X <Plug>(SubversiveSubstituteRangeConfirm)
nmap XX <Plug>(SubversiveSubstituteWordRangeConfirm)

" Unused y-mappings: yc yd ym yo yp yq yr ys yu yx yz
" ys is used for sneak.
" Use yp for "yank-paste", substituting the target without overwriting the
" unnamed buffer. In visual mode use P. 
nmap yp <Plug>(SubversiveSubstitute)
nmap ypp <Plug>(SubversiveSubstituteLine)
nmap yP <Plug>(SubversiveSubstituteToEndOfLine)

" Make Y behave as expected, though don't yank the trailing whitespace.
nnoremap Y yg_

" Maintain the cursor position when yanking a visual selection.
" http://ddrscott.github.io/blog/2016/yank-without-jank/
vnoremap y myy`y
vnoremap Y myY`y

" Ctrl-D for <Del> when in middle of line, from rsi.vim.
inoremap <expr> <C-D> col('.')>strlen(getline('.'))?"\<Lt>C-D>":"\<Lt>Del>"
cnoremap <expr> <C-D> getcmdpos()>strlen(getcmdline())?"\<Lt>C-D>":"\<Lt>Del>"

" Previous.
nnoremap [b <Cmd>bprevious<CR>
nmap [d <Plug>(coc-diagnostic-prev)
nnoremap [l <Cmd>lprevious<CR>
nnoremap [q <Cmd>cprevious<CR>
nnoremap [<Space> <Cmd>put!=repeat([''],v:count)<Bar>']+1<CR>

" Next.
nnoremap ]b <Cmd>bnext<CR>
nmap ]d <Plug>(coc-diagnostic-next)
nnoremap ]l <Cmd>lnext<CR>
nnoremap ]q <Cmd>cnext<CR>
nnoremap ]<Space> <Cmd>put=repeat([''],v:count)<Bar>'[-1<CR>

nnoremap <Leader>? <Cmd>Files<CR>
nnoremap <Leader>e <Cmd>NnnPicker %:p:h<CR>
nnoremap <Leader>g <Cmd>Git<CR>
nnoremap <Leader>p "*p
nnoremap <Leader>P "*P
xnoremap <Leader>p "*p
nnoremap <Leader>y "*y
nnoremap <Leader>Y "*Y
xnoremap <Leader>y "*y

" https://stackoverflow.com/a/16360104
autocmd Config CmdWinEnter * call s:unmap_cr()
autocmd Config BufReadPost * if !empty(&bt) | call s:unmap_cr() | endif

" Buffer MRU, adapted from:
" https://github.com/junegunn/fzf.vim/blob/dc71692255b62d1f67dc55c8e51ab1aa467b1d46/plugin/fzf.vim#L125
autocmd Config BufWinEnter,WinEnter * let g:buffer_timestamps[bufnr('')] = reltimefloat(reltime())
autocmd Config BufDelete * silent! call remove(g:buffer_timestamps, expand('<abuf>'))

" Filetype specific settings.
autocmd Config FileType css,scss call s:handle_ft_css()
autocmd Config FileType html call s:handle_ft_html()
autocmd Config FileType javascript,javascriptreact call s:handle_ft_javascript()
autocmd Config FileType json call s:handle_ft_json()
autocmd Config FileType qf call s:handle_ft_qf()
autocmd Config FileType typescript,typescriptreact call s:handle_ft_typescript()
autocmd Config FileType vim call s:handle_ft_vim()

" Open the quickfix and location windows automatically.
" https://noahfrederick.com/log/vim-streamlining-grep
autocmd Config QuickFixCmdPost [^l]* cwindow
autocmd Config QuickFixCmdPost l* lwindow

" Update signature help on jump placeholder.
autocmd Config User CocJumpPlaceholder call CocActionAsync('showSignatureHelp')

" Highlight the symbol and its references when holding the cursor.
autocmd Config CursorHold * silent call CocActionAsync('highlight')

" Call airline customization method.
autocmd Config User AirlineAfterInit call s:handle_airline_init()

" Custom FZF commands.
command! -bang -complete=dir -nargs=? Files call s:fzf_files(<q-args>, <bang>0)
command! -bang -complete=dir -nargs=? Grep call s:fzf_grep(<q-args>, <bang>0)
command! -bang -complete=dir -nargs=? Buffers call s:fzf_buffers(<q-args>, <bang>0)

function! s:unmap_cr() abort
    noremap <buffer> <CR> <CR>
endfunction

function! s:handle_ft_css() abort
    setlocal formatexpr=CocAction('formatSelected')
endfunction

function! s:handle_ft_html() abort
    setlocal formatexpr=CocAction('formatSelected')
endfunction

function! s:handle_ft_javascript() abort
    setlocal formatexpr=CocAction('formatSelected')
endfunction

function! s:handle_ft_json() abort
    setlocal formatexpr=CocAction('formatSelected')
endfunction

function! s:handle_ft_qf() abort
    setlocal norelativenumber
    setlocal nowrap

    call s:unmap_cr()
endfunction

function! s:handle_ft_typescript() abort
    setlocal formatexpr=CocAction('formatSelected')
endfunction

function! s:handle_ft_vim() abort
    " Use 4 spaces for indendation rather than the default 2.
    setlocal shiftwidth=4
    setlocal softtabstop=4
endfunction

" Remove the document percentage indicator.
function! s:handle_airline_init() abort
    let g:airline_section_z = airline#section#create(['linenr', 'maxlinenr', 'colnr'])
endfunction

" Inegrate LSP hover and keyword lookup.
function! s:show_documentation()
    if CocAction('hasProvider', 'hover')
        call CocActionAsync('doHover')
    else
        call feedkeys('K', 'in')
    endif
endfunction

function! GetGitBranch(name) abort
    " Shortcut git branches contain the ticket identifier preceeded by "sc-".
    let story = matchstr(a:name, 'sc-\d\+')

    " Use the identifier segment if we found one.
    if (strlen(story) > 0)
        return story[:strlen(story) - 1]
    endif

    " Otherwise the first ten characters.
    return a:name[:9]
endfunction

" Open an FZF mulit-file picker with the ability to change from
" version-controlled files to all files. Defaults to using the CWD, but
" optionally accepts an alternate directory.
function! s:fzf_files(dir, fullscreen) abort
    let l:name = 'files'
    let l:options = [
      \ '--bind', 'ctrl-f:change-prompt(Files(all): )+reload(fd -t f -uL)',
      \ '--padding', '1',
      \ '--prompt', 'Files: ',
      \ '--multi'
      \ ]
    let l:window = { 'width': 0.6, 'height': 0.4 }
    let l:fzf = { 'dir': a:dir, 'options': l:options, 'window': l:window }

    call fzf#run(fzf#wrap(l:name, l:fzf, a:fullscreen)) 
endfunction

" Parse lines from ripgrep for use in the quickfix window.
function! s:parse_fzf_grep_line(line) abort
    let parts = split(a:line, ':')

    " The names of the properties are dictated by setqflist.
    return {
      \ 'filename': parts[0],
      \ 'lnum': parts[1],
      \ 'col': parts[2],
      \ 'text': join(parts[3:], ':')
      \ }
endfunction

" Handle the chosen entries when doing a grep through FZF. The first file is
" always opened and selecting multiple files updates the quickfix list.
function! s:sinklist_fzf_grep(lines) abort
  let l:list = map(a:lines, 's:parse_fzf_grep_line(v:val)')
  let l:first = l:list[0]

  execute 'edit' escape(l:first.filename, ' %#\')
  execute l:first.lnum
  execute 'normal!' l:first.col . '|zz'

  if len(l:list) > 1
      call setqflist(l:list)
      cwindow
      wincmd p
  endif
endfunction

" Open an FZF window for live-grepping the CWD, optionally accepting an initial
" query. Adapted from the following examples:
" https://github.com/junegunn/fzf.vim/blob/master/README.md#example-advanced-ripgrep-integration
" https://github.com/junegunn/fzf/blob/master/ADVANCED.md#using-fzf-as-interactive-ripgrep-launcher
function! s:fzf_grep(query, fullscreen) abort
    let l:name = 'grep'
    let l:cmd = 'rg --column --line-number --no-heading --color=always --smart-case -- %s || true'
    let l:source = printf(cmd, shellescape(a:query))
    let l:reload = printf(cmd, '{q}')
    let l:options = [
      \ '--ansi',
      \ '--disabled',
      \ '--bind', 'change:reload:sleep 0.1; ' . l:reload,
      \ '--delimiter', ':',
      \ '--padding', '1',
      \ '--preview', 'bat --color=always {1} --highlight-line {2}',
      \ '--preview-window', 'right,50%,border-left,+{2}+3/3,~3,<80(up,50%,border-bottom)',
      \ '--prompt', 'Grep: ',
      \ '--query', a:query,
      \ '--multi'
      \ ]
    let l:window = { 'width': 0.9, 'height': 0.8 }
    let l:fzf = {
      \ 'options': l:options,
      \ 'sinklist': function('<sid>sinklist_fzf_grep'),
      \ 'source': l:source,
      \ 'window': l:window
      \ }

    call fzf#run(fzf#wrap(l:name, l:fzf, a:fullscreen)) 
endfunction

" Try to find an existing window with the given buffer number.
function! s:find_open_window(b) abort
    let l:tab_count = tabpagenr('$')
    let l:current_tab = tabpagenr() - 1

    " Loop through all tabs starting with the current one and wrapping.
    for l:tab_offset in range(0, tab_count - 1)
        let l:tab = (l:current_tab + l:tab_offset) % l:tab_count + 1
        let l:buffers = tabpagebuflist(l:tab)

        for l:window in range(1, len(l:buffers))
            if buffers[l:window - 1] == a:b
                return [l:tab, l:window]
            endif
        endfor
    endfor

    " We didn't find the buffer.
    return [0, 0]
endfunction

" Handle the chosen buffer entry. Try to navigate to an existing window if the
" buffer is already open, otherwise switch to the buffer in the current window.
function! s:sink_fzf_buffer(line) abort
    " Match the buffer number inside the brackets.
    let l:buffer = matchstr(a:line, '\[\zs[0-9]*\ze\]')
    let [l:tab, l:window] = s:find_open_window(l:buffer)

    if l:tab
        execute l:tab . 'tabnext'
        execute l:window . 'wincmd w'
        return
    endif

    execute 'buffer' l:buffer
endfunction

" Format the result line for the given buffer number.
function! s:format_fzf_buffer_line(b) abort
    let l:name = bufname(a:b)
    let l:name = empty(name) ? '[No Name]' : fnamemodify(name, ":p:~:.")
    return trim(printf("[%s]\t%s", a:b, name))
endfunction

" Sort the given buffer numbers based upon their timestamp in the global MRU.
function! s:sort_fzf_buffers(a, b) abort
    let l:timestamp_a = get(g:buffer_timestamps, a:a, a:a)
    let l:timestamp_b = get(g:buffer_timestamps, a:b, a:b)

    " Recently opened buffers will have larger timestamps.
    return l:timestamp_a < l:timestamp_b ? 1 : -1
endfunction

" Open an FZF window for choosing an open buffer. Adapted from fzf.vim:
" https://github.com/junegunn/fzf.vim/blob/dc71692255b62d1f67dc55c8e51ab1aa467b1d46/autoload/fzf/vim.vim#L716
function! s:fzf_buffers(query, fullscreen) abort
    " Listed buffers minus the quickfix.
    let l:buffers = filter(range(1, bufnr('$')), 'buflisted(v:val) && getbufvar(v:val, "&filetype") != "qf"')
    let l:sorted = sort(l:buffers, 's:sort_fzf_buffers')
    let l:source = map(l:sorted, 's:format_fzf_buffer_line(v:val)')

    let l:name = 'buffers'
    let l:options = [
      \ '--delimiter', '\t',
      \ '--padding', '1',
      \ '--prompt', 'Buffers: ',
      \ '--query', a:query,
      \ '--tiebreak', 'index'
      \ ]
    let l:window = { 'width': 0.6, 'height': 0.4 }
    let l:fzf = {
      \ 'options': l:options,
      \ 'sink': function('<sid>sink_fzf_buffer'),
      \ 'source': l:source,
      \ 'window': l:window
      \ }

    call fzf#run(fzf#wrap(l:name, l:fzf, a:fullscreen)) 
endfunction
