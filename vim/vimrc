" Manually set terminal features in Kitty until vim terminal feature detection
" is improved.
" https://sw.kovidgoyal.net/kitty/faq/#using-a-color-theme-with-a-background-color-does-not-work-well-in-vim
if &term == 'xterm-kitty'
  " Mouse support
  set mouse=a
  set ttymouse=sgr
  set balloonevalterm

  " Styled and colored underline support
  let &t_AU = "\e[58:5:%dm"
  let &t_8u = "\e[58:2:%lu:%lu:%lum"
  let &t_Us = "\e[4:2m"
  let &t_Cs = "\e[4:3m"
  let &t_ds = "\e[4:4m"
  let &t_Ds = "\e[4:5m"
  let &t_Ce = "\e[4:0m"

  " Strikethrough
  let &t_Ts = "\e[9m"
  let &t_Te = "\e[29m"

  " Truecolor support
  let &t_8f = "\e[38:2:%lu:%lu:%lum"
  let &t_8b = "\e[48:2:%lu:%lu:%lum"
  let &t_RF = "\e]10;?\e\\"
  let &t_RB = "\e]11;?\e\\"

  " Bracketed paste
  let &t_BE = "\e[?2004h"
  let &t_BD = "\e[?2004l"
  let &t_PS = "\e[200~"
  let &t_PE = "\e[201~"

  " Cursor control
  let &t_RC = "\e[?12$p"
  let &t_SH = "\e[%d q"
  let &t_RS = "\eP$q q\e\\"
  let &t_SI = "\e[5 q"
  let &t_SR = "\e[3 q"
  let &t_EI = "\e[1 q"
  let &t_VS = "\e[?12l"

  " Focus tracking
  let &t_fe = "\e[?1004h"
  let &t_fd = "\e[?1004l"
  execute "set <FocusGained>=\<Esc>[I"
  execute "set <FocusLost>=\<Esc>[O"

  " Window title
  let &t_ST = "\e[22;2t"
  let &t_RT = "\e[23;2t"

  " vim hardcodes background color erase even if the terminfo file does
  " not contain bce. This causes incorrect background rendering when
  " using a color theme with a background color in terminals such as
  " kitty that do not support background color erase.
  let &t_ut=''
endif

" Enable filetype and indent detection.
filetype plugin indent on

" Enable syntax highlighting.
syntax enable

" Use the Dracula color scheme.
colorscheme dracula

" Create new lines at the same indentation level.
set autoindent

" Detect file changes outside of vim and reload those files if not changed.
set autoread

" Use colors suitable for a dark background. The colorscheme should also set
" this value.
set background=dark

" Allow backspacing over everything in insert mode.
set backspace=indent,eol,start

" Don't put backup files in the current directory.
set backupdir^=$HOME/.vim/backup//

" Don't ring the bell.
set belloff=all

" Highlight the column after textwidth.
set colorcolumn=+1

" Don't put swap files in the current directory.
set directory^=$HOME/.vim/swap//

" Use utf-8 by default.
set encoding=utf-8

" Expand tabs to spaces in insert mode.
set expandtab

" Remove comment leader when joining lines.
set formatoptions+=j

" Allow for hidden buffers. Necessary for some plugins.
set hidden

" Highlight search results.
set hlsearch

" Ignore case when searching.
set ignorecase

" Show matches as search proceeds.
set incsearch

" Always show the status line.
set laststatus=2

" Show line numbers.
set number

" Make the line numbers relative.
set relativenumber

" Always show lines above and below cursor when scrolling.
set scrolloff=8

" Always show the signcolumn, otherwise it would shift the text each time
" diagnostics appear/become resolved.
set signcolumn=yes

" Use two spaces when indenting.
set shiftwidth=2

" Don't pass messages to |ins-completion-menu|.
set shortmess+=c

" Show a symbol for wrapped lines.
set showbreak=↪

" Show partial commands in the last line.
set showcmd

" Make search case-sensitive if capital letters are used.
set smartcase

" Use two spaces for the tab key.
set softtabstop=2

" Open horizontal splits below.
set splitbelow

" Open vertical splits to the right.
set splitright

" Statusline with useful information.
set statusline=
set statusline+=%{GetGitBranch()}
set statusline+=\ %f%m%r%q
set statusline+=%=
set statusline+=\ %y
set statusline+=\ %{&fileencoding?&fileencoding:&encoding}
set statusline+=\[%{&fileformat}\]
set statusline+=\ %l:%L
set statusline+=\ %c

" Enable true color.
set termguicolors

" Break text after 80 characters.
set textwidth=80

" Time out for key codes.
set ttimeout

" Wait up to 100ms after Esc for special key.
set ttimeoutlen=100

" Set the title of the terminal window appropriately.
set title

" Don't put undo files in the current directory.
set undodir^=$HOME/.vim/undo//

" Persistent undo.
set undofile

" coc.nvim recommends a lower updatetime, which is used by the highlight on
" CursorHold feature.
set updatetime=500

" Enable wildmenu (command-line completion).
set wildmenu

" Use fuzzy matching and the pum for the wildmenu.
set wildoptions=fuzzy,pum

" Wrap long lines.
set wrap

" Leave s for sneak.
" https://github.com/machakann/vim-sandwich/wiki/Introduce-vim-surround-keymappings
runtime START macros/sandwich/keymap/surround.vim

" The matchup-z% motion conflicts with sneak.
xmap <nop> <plug>(matchup-z%)
omap <nop> <plug>(matchup-z%)

" Text objects for git chunks.
omap ih <Plug>(GitGutterTextObjectInnerPending)
omap ah <Plug>(GitGutterTextObjectOuterPending)
xmap ih <Plug>(GitGutterTextObjectInnerVisual)
xmap ah <Plug>(GitGutterTextObjectOuterVisual)

" Text objects to select the nearest surrounded text automatically.
xmap iss <plug>(textobj-sandwich-auto-i)
xmap ass <plug>(textobj-sandwich-auto-a)
omap iss <plug>(textobj-sandwich-auto-i)
omap ass <plug>(textobj-sandwich-auto-a)

" Swappable (eg arguments) text objects.
xmap i, <plug>(swap-textobject-i)
omap i, <plug>(swap-textobject-i)
xmap a, <plug>(swap-textobject-a)
omap a, <plug>(swap-textobject-a)

" Reselect visual selection after indenting.
vnoremap < <gv
vnoremap > >gv

" Quick change the word under the cursor.
nmap cn *``cgn
nmap cN *``cgN

" Move vertically by visual line with wrapping enabled.
nnoremap j gj
nnoremap k gk

" Maintain the cursor position when joining lines.
nnoremap J mzJ`z

" Integrate LSP into keyword lookup.
nnoremap K <cmd>call ShowDocumentation()<cr>

" Keep the cursor centered when going through search results.
nnoremap n nzzzv
nnoremap N Nzzzv

" Ex mode is rarely useful.
nnoremap q @
nnoremap Q q

" Better redo.
nnoremap U <C-r>

" Make Y behave as expected, though don't yank the trailing whitespace.
nnoremap Y yg_

" Maintain the cursor position when yanking a visual selection.
" http://ddrscott.github.io/blog/2016/yank-without-jank/
vnoremap y myy`y
vnoremap Y myY`y

" Autocompletion: Use enter to trigger completions and tab to cycle options.
inoremap <expr> <cr> coc#pum#visible() ? coc#_select_confirm() : "\<C-g>u\<cr>"
inoremap <expr> <tab> coc#pum#visible() ? coc#pum#next(1) : "\<tab>"
inoremap <expr> <s-tab> coc#pum#visible() ? coc#pum#prev(1) : "\<s-tab>"

" Remap <C-f> and <C-b> for scroll float windows/popups.
nnoremap <silent><nowait><expr> <C-f> coc#float#has_scroll() ? coc#float#scroll(1) : "\<C-f>"
nnoremap <silent><nowait><expr> <C-b> coc#float#has_scroll() ? coc#float#scroll(0) : "\<C-b>"
inoremap <silent><nowait><expr> <C-f> coc#float#has_scroll() ? "\<C-r>=coc#float#scroll(1)\<cr>" : "\<Right>"
inoremap <silent><nowait><expr> <C-b> coc#float#has_scroll() ? "\<C-r>=coc#float#scroll(0)\<cr>" : "\<Left>"
vnoremap <silent><nowait><expr> <C-f> coc#float#has_scroll() ? coc#float#scroll(1) : "\<C-f>"
vnoremap <silent><nowait><expr> <C-b> coc#float#has_scroll() ? coc#float#scroll(0) : "\<C-b>"

" Previous/next.
nnoremap ]<space> <cmd>put=repeat([''],v:count)<bar>'[-1<cr>
nnoremap [<space> <cmd>put!=repeat([''],v:count)<bar>']+1<cr>
nnoremap [b <cmd>bprevious<cr>
nnoremap ]b <cmd>bnext<cr>
nmap [d <plug>(coc-diagnostic-prev)
nmap ]d <plug>(coc-diagnostic-next)
nmap [e <plug>(coc-diagnostic-prev-error)
nmap ]e <plug>(coc-diagnostic-next-error)
nmap ]h <Plug>(GitGutterNextHunk)
nmap [h <Plug>(GitGutterPrevHunk)
nnoremap [t gt
nnoremap ]t gT
nnoremap [q <cmd>cprevious<cr>
nnoremap ]q <cmd>cnext<cr>
nnoremap [Q <cmd>cfirst<cr>
nnoremap ]Q <cmd>clast<cr>
nnoremap [w <c-w>W
nnoremap ]w <c-w>w

nnoremap <CR> o
nnoremap <S-CR> O
nnoremap <A-CR> <Cmd>put=repeat([''],v:count)<Bar>'[-1<CR>
nnoremap <A-S-CR> <Cmd>put!=repeat([''],v:count)<Bar>']+1<CR>
nnoremap <A-B> <Cmd>bprevious<CR>
nnoremap <A-b> <Cmd>bnext<CR>

" Fast window switching.
nnoremap <A-1> <C-W>1w
nnoremap <A-2> <C-W>2w
nnoremap <A-3> <C-W>3w
nnoremap <A-4> <C-W>4w
nnoremap <A-5> <C-W>5w
nnoremap <A-6> <C-W>6w
nnoremap <A-7> <C-W>7w
nnoremap <A-8> <C-W>8w
nnoremap <A-9> <C-W>9w

" Move text in all directions.
nmap <A-Down> <Plug>MoveLineDown
nmap <A-Up> <Plug>MoveLineUp
nmap <A-Left> <Plug>MoveCharLeft
nmap <A-Right> <Plug>MoveCharRight
vmap <A-Down> <Plug>MoveBlockDown
vmap <A-Up> <Plug>MoveBlockUp
vmap <A-Left> <Plug>MoveBlockLeft
vmap <A-Right> <Plug>MoveBlockRight

" Use space for leader. 
let mapleader = ' '

nmap <silent> <Leader><Space> <Plug>(CommandT)
nnoremap <leader>d <cmd>bdelete<cr>
nmap <leader>ca <plug>(coc-codeaction)
nmap <leader>cc <plug>(coc-fix-current)
nmap <leader>cd <plug>(coc-definition)
nmap <leader>cf <plug>(coc-refactor)
nmap <leader>ci <plug>(coc-implementation)
nmap <leader>cl <cmd>CocList diagnostics<cr>
nmap <leader>cn <plug>(coc-rename)
nmap <leader>cr <plug>(coc-references)
nmap <leader>cs <plug>(coc-codeaction-selected)
xmap <leader>cs <plug>(coc-codeaction-selected)
nmap <leader>ct <plug>(coc-type-definition)
nnoremap <leader>e <cmd>NnnPicker %:p:h<CR>
nmap <leader>fa <Plug>(FerretAck)
nmap <leader>ff <Plug>(FerretAckWord)
nmap <leader>fl <Plug>(FerretLack)
nmap <leader>fq <Plug>(FerretQuack)
nmap <leader>fr <Plug>(FerretAcks)
nnoremap <leader>g <cmd>Git<cr>
nmap <Leader>hp <Plug>(GitGutterPreviewHunk)
nmap <Leader>hs <Plug>(GitGutterStageHunk)
nmap <Leader>hu <Plug>(GitGutterUndoHunk)
nnoremap <leader>p "*p
nnoremap <leader>P "*P
xnoremap <leader>p "*p
nnoremap <leader>q <cmd>quit<cr>
nnoremap <leader>s <cmd>update<cr>
nnoremap <leader>vc <cmd>edit $MYVIMRC<cr>
nnoremap <leader>vr <cmd>source $MYVIMRC<cr>
nnoremap <leader>wc <c-w>c
nnoremap <leader>wh <c-w>s
nnoremap <leader>wn <c-w>n
nnoremap <leader>wv <c-w>v
nnoremap <leader>x <cmd>exit<cr>
nnoremap <leader>y "*y
nnoremap <leader>Y "*Y
xnoremap <leader>y "*y

" Don't use default n³ mappings.
let g:nnn#set_default_mappings = 0

" Opens the n³ window in the same window like netrw.
let g:nnn#layout = 'enew'

" Use n³ when opening directories instead of netrw.
let g:nnn#replace_netrw = 1

" Use the git file scanner, which falls back to find when not in a repository.
" Please show untracked files, though. The debounce is nice in larger
" repositories and otherwise not noticeable.
let g:CommandTFileScanner = 'git'
let g:CommandTInputDebounce = 100
let g:CommandTGitIncludeUntracked = 1

" Use custom mappings for vim-move.
let g:move_map_keys = 0

" Suppress default ferret mappings.
let g:FerretMap = 0

" Don't show offscreen matches as they cause odd statusline issues.
let g:matchup_matchparen_offscreen = {}

" Use the sneak label mode for faster jumping.
let g:sneak#label = 1

" Coc Extensions. These should be automatically installed by coc.nvim.
let g:coc_global_extensions = [
      \ 'coc-css',
      \ 'coc-cssmodules',
      \ 'coc-docker',
      \ 'coc-eslint',
      \ 'coc-go',
      \ 'coc-html',
      \ 'coc-json',
      \ 'coc-lists',
      \ 'coc-prettier',
      \ 'coc-solargraph',
      \ 'coc-tsserver',
      \ 'coc-vimlsp'
      \ ]

" More colorful JSX.
let g:vim_jsx_pretty_colorful_config = 1

augroup CocEvents
  autocmd!
  " Update signature help on jump placeholder.
  autocmd User CocJumpPlaceholder call CocActionAsync('showSignatureHelp')

  " Highlight the symbol and its references when holding the cursor.
  autocmd CursorHold * silent call CocActionAsync('highlight')
augroup end

augroup JsonEvents
  autocmd!
  autocmd BufNewFile,BufRead .eslintrc.json setlocal filetype=jsonc
  autocmd BufNewFile,BufRead coc-settings.json setlocal filetype=jsonc
  autocmd BufNewFile,BufRead tsconfig.json setlocal filetype=jsonc
augroup END

augroup UnmapEnterEvents
  autocmd!
  autocmd BufReadPost * if !empty(&bt) | call DisableEnderMapping() | endif
  autocmd CmdWinEnter * call DisableEnderMapping()
  autocmd FileType qf call DisableEnderMapping()
augroup END

function! GetGitBranch() abort
  let fugitive = FugitiveStatusline()

  " This file is not in a git directory.
  if (strlen(fugitive) == 0)
    return ''
  endif

  let matches = matchlist(fugitive, '^\[Git(\(.\+\))\]$')

  " Could not parse the fugitive output for some reason.
  if (len(matches) == 0)
    return ''
  endif

  let branch = matches[1]

  " Shortcut git branches contain the ticket identifier preceeded by "sc-".
  let story = matchstr(branch, 'sc-\d\+')

  " Use the identifier segment if we found one.
  if (strlen(story) > 0)
    return '[' . story[:strlen(story) - 1] . ']'
  endif

  " Otherwise the first ten characters.
  return '[' . branch[:9] . ']'
endfunction

" Show documentation in preview window.
function! ShowDocumentation() abort
  if CocAction('hasProvider', 'hover')
    call CocActionAsync('doHover')
  else
    call feedkeys('K', 'in')
  endif
endfunction

function! DisableEnderMapping() abort
  nnoremap <buffer> <CR> <CR>
endfunction

let s:RE_WORD = '\%(\w\+\)'
let s:RE_ATTR_NAME = '\%([a-zA-Z0-9\-_:@.]\+\)'
let s:RE_QUOTED_STR = '\%(".\{-}"\|''.\{-}''\)'
let s:RE_JSX_BLOCK = '\%({\_.\{-}\%(}}\|}\)\%(\/>\|[ \n>]\)\@=\)'
let s:RE_ATTR_VALUE = '\%(' . s:RE_QUOTED_STR . '\|' . s:RE_WORD . '\|' . s:RE_JSX_BLOCK . '\)'
let s:RE_ATTR_RHS = '\%(=' . s:RE_ATTR_VALUE . '\)\='
let s:RE_ATTR = '\%(' . s:RE_ATTR_NAME . s:RE_ATTR_RHS . '\)'
let s:RE_ATTR_WITH_SPACE = '\%(\_s*' . s:RE_ATTR . '\)'
" let s:RE_ATTR_A = '\(' . s:RE_ATTR_WITH_SPACE . '\)'
" let s:RE_JSX_TAG = '<?\?\h\w*\_s*\zs\%(' . s:RE_ATTR_WITH_SPACE . '\)*\ze\_s*/\?>'

call textobj#user#plugin('tagattr', {
\   'attr-i': {
\     'pattern': s:RE_ATTR,
\     'select': 'ix',
\   },
\   'attr-a': {
\     'pattern': s:RE_ATTR_WITH_SPACE,
\     'select': 'ax',
\   },
\ })
