" Manually set terminal features in Kitty until vim terminal feature detection
" is improved.
" https://sw.kovidgoyal.net/kitty/faq/#using-a-color-theme-with-a-background-color-does-not-work-well-in-vim
if &term == 'xterm-kitty'
  " Mouse support
  set mouse=a
  set ttymouse=sgr
  set balloonevalterm

  " Styled and colored underline support
  let &t_AU = "\e[58:5:%dm"
  let &t_8u = "\e[58:2:%lu:%lu:%lum"
  let &t_Us = "\e[4:2m"
  let &t_Cs = "\e[4:3m"
  let &t_ds = "\e[4:4m"
  let &t_Ds = "\e[4:5m"
  let &t_Ce = "\e[4:0m"

  " Strikethrough
  let &t_Ts = "\e[9m"
  let &t_Te = "\e[29m"

  " Truecolor support
  let &t_8f = "\e[38:2:%lu:%lu:%lum"
  let &t_8b = "\e[48:2:%lu:%lu:%lum"
  let &t_RF = "\e]10;?\e\\"
  let &t_RB = "\e]11;?\e\\"

  " Bracketed paste
  let &t_BE = "\e[?2004h"
  let &t_BD = "\e[?2004l"
  let &t_PS = "\e[200~"
  let &t_PE = "\e[201~"

  " Cursor control
  let &t_RC = "\e[?12$p"
  let &t_SH = "\e[%d q"
  let &t_RS = "\eP$q q\e\\"
  let &t_SI = "\e[5 q"
  let &t_SR = "\e[3 q"
  let &t_EI = "\e[1 q"
  let &t_VS = "\e[?12l"

  " Focus tracking
  let &t_fe = "\e[?1004h"
  let &t_fd = "\e[?1004l"
  execute "set <FocusGained>=\<Esc>[I"
  execute "set <FocusLost>=\<Esc>[O"

  " Window title
  let &t_ST = "\e[22;2t"
  let &t_RT = "\e[23;2t"

  " vim hardcodes background color erase even if the terminfo file does not
  " contain bce. This causes incorrect background rendering when using a color
  " theme with a background color in terminals such as
  " kitty that do not support background color erase.
  let &t_ut=''
endif

" Enable filetype and indent detection.
filetype plugin indent on

" Enable syntax highlighting.
syntax enable

" Use the Dracula color scheme.
colorscheme dracula

" Create new lines at the same indentation level.
set autoindent

" Detect file changes outside of vim and reload those files if not changed.
set autoread

" Use colors suitable for a dark background. The colorscheme should also set
" this value.
set background=dark

" Allow backspacing over everything in insert mode.
set backspace=indent,eol,start

" Don't put backup files in the current directory.
set backupdir^=$HOME/.vim/backup//

" Don't ring the bell.
set belloff=all

" Highlight the column after textwidth.
set colorcolumn=+1

" Don't put swap files in the current directory.
set directory^=$HOME/.vim/swap//

" Use utf-8 by default.
set encoding=utf-8

" Expand tabs to spaces in insert mode.
set expandtab

" Remove comment leader when joining lines.
set formatoptions+=j

" Allow for hidden buffers. Necessary for some plugins.
set hidden

" Highlight search results.
set hlsearch

" Ignore case when searching.
set ignorecase

" Show matches as search proceeds.
set incsearch

" Always show the status line.
set laststatus=2

" Show line numbers.
set number

" Make the line numbers relative.
set relativenumber

" Always show lines above and below cursor when scrolling.
set scrolloff=8

" Always show the signcolumn, otherwise it would shift the text each time
" diagnostics appear/become resolved.
set signcolumn=yes

" Use two spaces when indenting.
set shiftwidth=2

" Don't pass messages to |ins-completion-menu|.
set shortmess+=c

" Show a symbol for wrapped lines.
set showbreak=↪

" Show partial commands in the last line.
set showcmd

" Make search case-sensitive if capital letters are used.
set smartcase

" Use two spaces for the tab key.
set softtabstop=4

" Open horizontal splits below.
set splitbelow

" Open vertical splits to the right.
set splitright

" Statusline with useful information.
set statusline=
set statusline+=%{GetStatuslineGit()}
set statusline+=\ %f%m%r%q
set statusline+=%=\ 
set statusline+=%#ErrorMsg#
set statusline+=%{GetStatuslineLsp()}
set statusline+=%*
set statusline+=\ %y
set statusline+=\ %{&fileencoding?&fileencoding:&encoding}
set statusline+=\[%{&fileformat}\]
set statusline+=\ %l:%L
set statusline+=\ %c

" Enable true color.
set termguicolors

" Break text after 80 characters.
set textwidth=80

" Time out for key codes.
set ttimeout

" Wait up to 100ms after Esc for special key.
set ttimeoutlen=100

" Set the title of the terminal window appropriately.
set title

" Don't put undo files in the current directory.
set undodir^=$HOME/.vim/undo//

" Persistent undo.
set undofile

" Faster update time for git signs, etc. 
set updatetime=500

" Enable wildmenu (command-line completion).
set wildmenu

" Use fuzzy matching and the pum for the wildmenu.
set wildoptions=fuzzy,pum

" Wrap long lines.
set wrap

" Use space for leader. 
let mapleader = ' '

" Update the vim indent options to use less space for line continuation.
let g:vim_indent = #{
    \ line_continuation: shiftwidth(),
    \ more_in_bracket_block: v:false,
    \ searchpair_timeout: 100,
    \ }

" Disable default mappings in the following plugins.
let g:FerretMap = 0
let g:gitgutter_map_keys = 0
let g:nnn#set_default_mappings = 0
let g:sandwich_no_default_key_mappings = 1
let g:swap_no_default_key_mappings = 1

" Use the git file scanner, which falls back to find when not in a repository.
" Please show untracked files, though. The debounce is nice in larger
" repositories and otherwise not noticeable.
let g:CommandTFileScanner = 'git'
let g:CommandTInputDebounce = 100
let g:CommandTGitIncludeUntracked = 1

" Use bars for git signs as they are easier to read at a glance.
let g:gitgutter_sign_added = '|'
let g:gitgutter_sign_modified = '|'
let g:gitgutter_sign_removed = '|'
let g:gitgutter_sign_removed_first_line = '|'
let g:gitgutter_sign_removed_above_and_below = '|'
let g:gitgutter_sign_modified_removed = '|'

" GitGutter signs take priority over LSP signs by default.
let g:gitgutter_sign_priority = 5

" More colorful JSX.
let g:vim_jsx_pretty_colorful_config = 1

" Don't show offscreen matches as they cause odd statusline issues.
let g:matchup_matchparen_offscreen = {}

" Opens the n³ window in the same window like netrw.
let g:nnn#layout = 'enew'

" Use n³ when opening directories instead of netrw.
let g:nnn#replace_netrw = 1

" Use the sneak label mode for faster jumping.
let g:sneak#label = 1

" Configure available language servers.
let servers = []

if executable('vscode-css-language-server')
    call add(servers, #{
        \ filetype: ['css', 'scss'],
        \ path: system('which vscode-css-language-server')[:-2],
        \ args: ['--stdio']
        \ })
endif

if executable('vscode-html-language-server')
    call add(servers, #{
        \ filetype: ['html'],
        \ path: system('which vscode-html-language-server')[:-2],
        \ args: ['--stdio']
        \ })
endif

if executable('typescript-language-server')
    call add(servers, #{
        \ filetype: [
        \   'javascript', 'javascriptreact', 'typescript', 'typescriptreact'
        \ ],
        \ path: system('which typescript-language-server')[:-2],
        \ args: ['--stdio']
        \ })
endif

if executable('vim-language-server')
    call add(servers, #{
        \ filetype: ['vim'],
        \ path: system('which vim-language-server')[:-2],
        \ args: ['--stdio']
        \ })
endif

if len(servers) > 0
    " Load the lsp plugin so we can call its commands.
    packadd lsp

    call LspAddServer(servers)
    call LspOptionsSet({
        \ 'showDiagOnStatusLine': v:true,
        \ 'snippetSupport': v:true,
        \ 'usePopupInCodeAction': v:true
        \ })
endif

" Swappable (eg arguments) text objects.
xmap i, <Plug>(swap-textobject-i)
omap i, <Plug>(swap-textobject-i)
xmap a, <Plug>(swap-textobject-a)
omap a, <Plug>(swap-textobject-a)

" Sandwich text-object for "m"atching characters.
xmap im <Plug>(textobj-sandwich-auto-i)
omap im <Plug>(textobj-sandwich-auto-i)
xmap am <Plug>(textobj-sandwich-auto-a)
omap am <Plug>(textobj-sandwich-auto-a)

" Use tab for cycling through completion entries in insert mode.
" inoremap <expr> <CR> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"
inoremap <expr> <Tab> pumvisible() ? "\<C-n>" : "\<Tab>"
inoremap <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"

" Using enter and backspace for "open" is more intuitive.
nnoremap <CR> o
vnoremap <CR> o
nnoremap <S-CR> <Cmd>put=repeat([''],v:count)<Bar>'[-1<CR>
nnoremap <Backspace> O
vnoremap <Backspace> O
nnoremap <S-Backspace> <Cmd>put!=repeat([''],v:count)<Bar>']+1<CR>

" Reselect visual selection after indenting.
vnoremap < <gv
vnoremap > >gv

" Change matching characters.
nmap cm <Plug>(sandwich-replace)
nmap cmm <Plug>(sandwich-replace-auto)

" Quick change the word under the cursor.
nmap cn *``cgn
nmap cN *``cgN

" Use multiline "f" from sneak.
nmap f <Plug>Sneak_f
nmap F <Plug>Sneak_F
xmap f <Plug>Sneak_f
xmap F <Plug>Sneak_F
omap f <Plug>Sneak_f
omap F <Plug>Sneak_F

" Move vertically by visual line with wrapping enabled.
nnoremap j gj
nnoremap k gk

" More intuitive go to screen and line positions.
nnoremap H _
vnoremap H _
nnoremap J L
vnoremap J L
nnoremap K H
vnoremap K H
nnoremap L g_
vnoremap L g_

nmap ym <Plug>(sandwich-add)
nmap dm <Plug>(sandwich-delete)
nmap dmm <Plug>(sandwich-delete-auto)

" Keep the cursor centered when going through search results.
nnoremap n nzzzv
nnoremap N Nzzzv

" Use "o" for controlling comments.
xmap o <Plug>Commentary
nmap o <Plug>Commentary
omap o <Plug>Commentary
nmap oo <Plug>CommentaryLine
nmap O <Plug>Commentary<Plug>Commentary

" Ex mode is rarely useful.
nnoremap q @
nnoremap Q q

" Use s/S for sneak everywhere since it won't confict with surround mappings.
omap s <Plug>Sneak_s
omap S <Plug>Sneak_S
xmap S <Plug>Sneak_S

" Use multiline "t" from sneak.
nmap t <Plug>Sneak_t
nmap T <Plug>Sneak_T
xmap t <Plug>Sneak_t
xmap T <Plug>Sneak_T
omap t <Plug>Sneak_t
omap T <Plug>Sneak_T

" Better redo.
nnoremap U <C-r>

" All "x" mappings are easily peformed with "d" so use wildfire instead.
map x <Plug>(wildfire-fuel)
nmap X <Plug>(wildfire-quick-select)
xmap X <Plug>(wildfire-water)

" Make Y behave as expected, though don't yank the trailing whitespace.
nnoremap Y yg_

" Maintain the cursor position when yanking a visual selection.
" http://ddrscott.github.io/blog/2016/yank-without-jank/
vnoremap y myy`y
vnoremap Y myY`y

" Alt for prev/next "unimpaired" style mappings are much easier than brackets.
nnoremap <A-CR> :m .+1<cr>==
vnoremap <A-CR> :m '>+1<cr>gv=gv
nnoremap <A-Backspace> :m .-2<cr>==
vnoremap <A-Backspace> :m '<-2<cr>gv=gv
nnoremap <A-B> <Cmd>bprevious<CR>
nnoremap <A-b> <Cmd>bnext<CR>
nnoremap <A-D> <Cmd>LspDiagPrev<CR>
nnoremap <A-d> <Cmd>LspDiagNext<CR>
nnoremap <A-L> <Cmd>lprevious<CR>
nnoremap <A-l> <Cmd>lnext<CR>
nnoremap <A-Q> <Cmd>cprevious<CR>
nnoremap <A-q> <Cmd>cnext<CR>
xnoremap <A-X> <Cmd>LspSelectionShrink<CR>
nnoremap <A-x> <Cmd>LspSelectionExpand<CR>
xnoremap <A-x> <Cmd>LspSelectionExpand<CR>

nnoremap <Leader><Space> <Cmd>CommandT<CR>
nnoremap <Leader><CR> <Cmd>update<CR>
nnoremap <Leader><S-CR> <Cmd>exit<CR>
nnoremap <Leader><Backspace> <Cmd>bdelete<CR>
nnoremap <Leader><S-Backspace> <Cmd>quit<CR>
nnoremap <Leader>b <Cmd>CommandTBuffer<CR>
nnoremap <Leader>ca <Cmd>LspCodeAction<CR>
nnoremap <Leader>cc <Cmd>LspDiagCurrent<CR>
nnoremap <Leader>cd <Cmd>LspGotoDefinition<CR>
nnoremap <Leader>cf <Cmd>LspFormat<CR>
nnoremap <leader>ch <Cmd>LspDiagShow<CR>
nnoremap <Leader>ci <Cmd>LspIncomingCalls<CR>
nnoremap <Leader>cl <Cmd>LspOutline<CR>
nnoremap <Leader>cm <Cmd>LspGotoImpl<CR>
nnoremap <Leader>cn <Cmd>LspRename<CR>
nnoremap <Leader>co <Cmd>LspOutgoingCalls<CR>
nnoremap <Leader>cr <Cmd>LspShowReferences<CR>
nnoremap <Leader>cs <Cmd>LspSymbolSearch<CR>
nnoremap <Leader>ct <Cmd>LspGotoTypeDef<CR>
nnoremap <Leader>e <Cmd>NnnPicker %:p:h<CR>
nnoremap <Leader>f gq
xnoremap <Leader>f gq
nnoremap <Leader>ff gqq
nnoremap <Leader>g <Cmd>Git<CR>
nmap <Leader>hp <Plug>(GitGutterPreviewHunk)
nmap <Leader>hs <Plug>(GitGutterStageHunk)
nmap <Leader>hu <Plug>(GitGutterUndoHunk)
nnoremap <Leader>j J
xnoremap <Leader>j J
nnoremap <Leader>m m
" nnoremap <Leader>mm <Cmd>make %<CR>
nnoremap <Leader>p "*p
nnoremap <Leader>P "*P
xnoremap <Leader>p "*p
nmap <Leader>s<Space> <Plug>(FerretAck)
nmap <leader>ss <Plug>(FerretAckWord)
nmap <leader>sl <Plug>(FerretLack)
nmap <leader>sq <Plug>(FerretQuack)
nmap <leader>sr <Plug>(FerretAcks)
nnoremap <leader>vc <cmd>edit $MYVIMRC<cr>
nnoremap <leader>vr <cmd>source $MYVIMRC<cr>
nnoremap <Leader>w gw
xnoremap <Leader>w gw
nnoremap <Leader>ww gww
nnoremap <leader>y "*y
nnoremap <leader>Y "*Y
xnoremap <leader>y "*y

augroup Config
    autocmd!
    " In certain buffers, mapping <CR> can be problematic.
    autocmd BufReadPost * if !empty(&bt) | call s:reset_cr_mappings() | endif
    autocmd CmdWinEnter * call s:reset_cr_mappings()
    autocmd FileType qf call s:reset_cr_mappings()

    " These files should be treated as JSONC.
    autocmd BufNewFile,BufRead .eslintrc.json setlocal filetype=jsonc
    autocmd BufNewFile,BufRead tsconfig.json setlocal filetype=jsonc

    autocmd FileType javascript,javascriptreact call s:handle_ft_javascript()
    autocmd FileType typescript,typescriptreact call s:handle_ft_typescript()
augroup end

function! s:reset_cr_mappings() abort
    noremap <buffer> <CR> <CR>
endfunction

function! s:handle_ft_javascript() abort
    " Use eslint for the make command.
    setlocal makeprg=npx\ eslint\ --fix\ --format\ compact
    setlocal errorformat=%f:\ line\ %l\\,\ col\ %c\\,\ %m,%-G%.%#

    " Prettier.
    setlocal formatprg=npx\ prettier\ --loglevel\ silent\ --stdin-filepath\ %
endfunction

function! s:handle_ft_typescript() abort
    " The yats.vim plugin sets a custom formatexpr that doesn't work well.
    setlocal formatexpr&

    " Settings are otherwise the same as for JS.
    call s:handle_ft_javascript()
endfunction

function! s:handle_ft_vim() abort
    " Use 4 spaces for indendation rather than the default 2.
    setlocal shiftwidth=4
    setlocal softtabstop=4
endfunction

" Global statusline function to show LSP diagnostic counts.
function! GetStatuslineLsp() abort
    let errorCount = get(lsp#lsp#ErrorCount(), 'Error', 0)
    let warnCount = get(lsp#lsp#ErrorCount(), 'Warn', 0)

    let statuses = []

    if (!empty(warnCount))
        call add(statuses, 'W:' . warnCount)
    endif

    if (!empty(errorCount))
        call add(statuses, 'E:' . errorCount)
    endif

    return join(statuses, ',')
endfunction

" Global statusline function to show the Git branch. 
function! GetStatuslineGit() abort
    let fugitive = FugitiveStatusline()

    " This file is not in a git directory.
    if (strlen(fugitive) == 0)
        return ''
    endif

    let matches = matchlist(fugitive, '^\[Git(\(.\+\))\]$')

    " Could not parse the fugitive output for some reason.
    if (len(matches) == 0)
        return ''
    endif

    let branch = matches[1]

    " Shortcut git branches contain the ticket identifier preceeded by "sc-".
    let story = matchstr(branch, 'sc-\d\+')

    " Use the identifier segment if we found one.
    if (strlen(story) > 0)
        return '[' . story[:strlen(story) - 1] . ']'
    endif

    " Otherwise the first ten characters.
    return '[' . branch[:9] . ']'
endfunction

let s:RE_WORD = '\%(\w\+\)'
let s:RE_ATTR_NAME = '\%([a-zA-Z0-9\-_:@.]\+\)'
let s:RE_QUOTED_STR = '\%(".\{-}"\|''.\{-}''\)'
let s:RE_JSX_BLOCK = '\%({\_.\{-}\%(}}\|}\)\%(\/>\|[ \n>]\)\@=\)'
let s:RE_ATTR_VALUE = '\%(' . s:RE_QUOTED_STR . '\|' . s:RE_WORD . '\|' . s:RE_JSX_BLOCK . '\)'
let s:RE_ATTR_RHS = '\%(=' . s:RE_ATTR_VALUE . '\)\='
let s:RE_ATTR = '\%(' . s:RE_ATTR_NAME . s:RE_ATTR_RHS . '\)'
let s:RE_ATTR_WITH_SPACE = '\%(\_s*' . s:RE_ATTR . '\)'
" let s:RE_ATTR_A = '\(' . s:RE_ATTR_WITH_SPACE . '\)'
" let s:RE_JSX_TAG = '<?\?\h\w*\_s*\zs\%(' . s:RE_ATTR_WITH_SPACE . '\)*\ze\_s*/\?>'

call textobj#user#plugin('tagattr', {
\   'attr-i': {
\     'pattern': s:RE_ATTR,
\     'select': 'ix',
\   },
\   'attr-a': {
\     'pattern': s:RE_ATTR_WITH_SPACE,
\     'select': 'ax',
\   },
\ })

function! SynStack()
  if !exists("*synstack")
    return
  endif
  echo map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name")')
endfunc
